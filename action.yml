name: 'virtme-ng Action'
description: 'Run CI workloads inside a virtme-ng VM with a specific kernel'

branding:
  icon: 'cpu'
  color: 'orange'

inputs:
  name:
    description: 'Name for the kernel build cache (e.g., my-project-kernel)'
    required: true
  kernel-url:
    description: 'Git repository URL for the kernel source'
    required: true
  kernel-tag:
    description: 'Git tag or branch to checkout (e.g., v6.12, master)'
    required: true
  version:
    description: 'Cache version string, bump to invalidate the cache (e.g., v1, v2)'
    required: false
    default: 'v2'
  kconfig:
    description: 'Path to a kconfig fragment file (relative to the repo root)'
    required: false
    default: ''
  cpus:
    description: 'Number of CPUs for the VM (default: all available)'
    required: false
    default: ''
  memory:
    description: 'Memory for the VM, e.g. 4G, 512M (default: QEMU default)'
    required: false
    default: ''
  network:
    description: 'Network mode for the VM, e.g. user (default: none)'
    required: false
    default: ''
  run:
    description: 'Commands to execute inside the VM'
    required: true

outputs:
  kernel-sha:
    description: 'Short commit SHA (12 chars) of the resolved kernel commit'
    value: ${{ steps.kernel-sha.outputs.sha }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        errors=0
        if [ -z "${{ inputs.name }}" ]; then
          echo "::error::Input 'name' is required but was not provided."
          errors=$((errors + 1))
        fi
        if [ -z "${{ inputs.kernel-url }}" ]; then
          echo "::error::Input 'kernel-url' is required but was not provided."
          errors=$((errors + 1))
        fi
        if [ -z "${{ inputs.kernel-tag }}" ]; then
          echo "::error::Input 'kernel-tag' is required but was not provided."
          errors=$((errors + 1))
        fi
        if [ -z "${{ inputs.run }}" ]; then
          echo "::error::Input 'run' is required but was not provided."
          errors=$((errors + 1))
        fi
        if [ -n "${{ inputs.kconfig }}" ] && [ ! -f "$GITHUB_WORKSPACE/${{ inputs.kconfig }}" ]; then
          echo "::error::kconfig file not found: '${{ inputs.kconfig }}' (resolved to '$GITHUB_WORKSPACE/${{ inputs.kconfig }}')"
          errors=$((errors + 1))
        fi
        if [ "$errors" -gt 0 ]; then
          exit 1
        fi

    - name: Install dependencies
      shell: bash
      run: bash "${{ github.action_path }}/scripts/install-deps.sh"

    - name: Restore kernel SHA from prior job
      id: sha-cache-restore
      uses: actions/cache/restore@v4
      with:
        path: .vng-sha-${{ inputs.name }}
        key: vng-sha-${{ inputs.name }}-${{ inputs.kernel-tag }}-${{ github.run_id }}

    - name: Resolve kernel commit SHA
      id: kernel-sha
      shell: bash
      run: |
        SHA_FILE="$GITHUB_WORKSPACE/.vng-sha-${{ inputs.name }}/sha"

        # Use cached SHA from a prior job in this run
        if [ -f "$SHA_FILE" ]; then
          SHA=$(cat "$SHA_FILE")
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "Using cached kernel SHA from prior job: $SHA"
          exit 0
        fi

        # For annotated tags, ls-remote returns both the tag object and the
        # dereferenced commit (tagged ^{}). Prefer the dereferenced commit
        # so we always resolve to the same underlying commit SHA.
        REMOTE_OUTPUT=$(git ls-remote "${{ inputs.kernel-url }}" "${{ inputs.kernel-tag }}" "${{ inputs.kernel-tag }}^{}")
        if [ -z "$REMOTE_OUTPUT" ]; then
          echo "::error::Could not resolve ref '${{ inputs.kernel-tag }}' from ${{ inputs.kernel-url }}"
          exit 1
        fi
        # Take ^{} (dereferenced) line if present, otherwise the direct ref
        DEREF=$(echo "$REMOTE_OUTPUT" | { grep '\^{}' || true; } | awk '{print $1}')
        DIRECT=$(echo "$REMOTE_OUTPUT" | { grep -v '\^{}' || true; } | awk '{print $1}')
        FULL_SHA="${DEREF:-$DIRECT}"
        SHA="${FULL_SHA:0:12}"

        # Write SHA to file for cross-job propagation
        mkdir -p "$GITHUB_WORKSPACE/.vng-sha-${{ inputs.name }}"
        echo -n "$SHA" > "$SHA_FILE"

        echo "sha=$SHA" >> "$GITHUB_OUTPUT"
        echo "Resolved ${{ inputs.kernel-tag }} -> $SHA"

    - name: Save kernel SHA for subsequent jobs
      if: steps.sha-cache-restore.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: .vng-sha-${{ inputs.name }}
        key: vng-sha-${{ inputs.name }}-${{ inputs.kernel-tag }}-${{ github.run_id }}

    - name: Cache kernel build
      uses: actions/cache@v4
      id: kernel-cache
      with:
        path: linux
        key: vng-kernel-${{ inputs.name }}-${{ steps.kernel-sha.outputs.sha }}-${{ inputs.version }}

    - name: Clone and build kernel
      if: steps.kernel-cache.outputs.cache-hit != 'true'
      shell: bash
      run: bash "${{ github.action_path }}/scripts/build-kernel.sh"
      env:
        VNG_KERNEL_URL: ${{ inputs.kernel-url }}
        VNG_KERNEL_TAG: ${{ inputs.kernel-tag }}
        VNG_KCONFIG: ${{ inputs.kconfig }}
        VNG_KERNEL_DIR: ${{ github.workspace }}/linux

    - name: Run workload in VM
      shell: bash
      run: bash "${{ github.action_path }}/scripts/run-workload.sh"
      env:
        VNG_COMMANDS: ${{ inputs.run }}
        VNG_KERNEL_DIR: ${{ github.workspace }}/linux
        VNG_CPUS: ${{ inputs.cpus }}
        VNG_MEMORY: ${{ inputs.memory }}
        VNG_NETWORK: ${{ inputs.network }}
